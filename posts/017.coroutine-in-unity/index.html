<!doctype html><html lang=zh-cn><head><meta charset=utf-8><link crossorigin=anonymous media=all rel=stylesheet href=https://lightjiao.github.io/css/frameworks.css?20201110115045><link crossorigin=anonymous media=all rel=stylesheet href=https://lightjiao.github.io/css/github.css?20201110115045><link crossorigin=anonymous media=all rel=stylesheet href=https://lightjiao.github.io/css/user.css?20201110115045><meta name=viewport content="width=device-width"><title>Unity协程的原理与应用 - Lightjiao的博客</title><meta property="og:url" content="https://lightjiao.github.io/posts/017.coroutine-in-unity/"><meta property="og:site_name" content="Lightjiao的博客"><meta property="og:type" content="article"><meta property="og:title" content="Unity协程的原理与应用"><meta property="og:description" content><meta name=description content><link rel=icon type=image/x-icon class=js-site-favicon href=https://lightjiao.github.io/favicon.ico><link rel="shortcut icon" href=https://lightjiao.github.io/favicon.ico><meta name=theme-color content="#1e2327"><script async src="https://www.googletagmanager.com/gtag/js?id="></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','');</script></head><body class="env-production emoji-size-boost page-responsive page-profile"><div class="position-relative js-header-wrapper"><span class="Progress progress-pjax-loader position-fixed width-full js-pjax-loader-bar"><span class="progress-pjax-loader-bar top-0 left-0" style=width:0%></span></span><div class="Header js-details-container Details flex-wrap flex-lg-nowrap p-responsive" role=banner><div class="Header-item d-none d-lg-flex"><a class=Header-link href=https://lightjiao.github.io aria-label=Homepage data-ga-click="Header, go to dashboard, icon:logo"><svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg><span class=site-title-text>Lightjiao的博客</span></a></div><div class="Header-item Header-item--full flex-column flex-lg-row width-full flex-order-2 flex-lg-order-none mr-0 mr-lg-3 mt-3 mt-lg-0 Details-content--hidden"><div class="header-search flex-self-stretch flex-lg-self-auto mr-0 mr-lg-3 mb-3 mb-lg-0 scoped-search site-scoped-search js-site-search position-relative js-jump-to" role=combobox aria-owns=jump-to-results aria-label="Search or jump to" aria-haspopup=listbox aria-expanded=false><div class=position-relative></div></div></div><div class="Header-item Header-item--full flex-justify-center d-lg-none position-relative" style=margin-right:auto><a class=Header-link href=https://lightjiao.github.io aria-label=Homepage data-ga-click="Header, go to dashboard, icon:logo"><svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" width="32" aria-hidden="true"><path style="fill-rule:evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.077797-1.481017-.077797-2.151017C5.9433346 12.597005 6.1160655 11.824118 6.56 11.53 4.78 11.33 3.8013559 10.978983 3.5810169 7.6647458 3.9355372 4.6446549 5.3653277 3.8240736 8.0538984 3.639661 10.967753 3.8102868 12.141357 4.4459308 12.425085 7.6477967 12.255593 10.378813 11.25 11.33 9.47 11.53c.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38C13.806446 14.490656 15.999121 11.437004 16 8c0-4.42-3.58-8-8-8z"/><rect style="fill-rule:evenodd" ry=".23728813" y="6.3898306" x="6.0169492" height="1.0847455" width="3.9830508"/></svg><span class=site-title-text>Lightjiao的博客</span></a></div><div class="Header-item position-relative mr-0 d-none d-lg-flex Details-content--hidden"><div class="header-search flex-self-stretch flex-lg-self-auto mr-0 mr-lg-3 mb-3 mb-lg-0 position-relative js-jump-to"><div class=position-relative><form class=js-site-search-form role=search action=https://cse.google.com/cse method=get><input type=hidden name=cx value=012421816302566090497:mssmt7t6py4>
<label class="form-control input-sm header-search-wrapper p-0 header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center js-chromeless-input-container"><input type=text class="header-search-form form-control input-sm header-search-input jump-to-field js-jump-to-field" name=q placeholder=Search autocapitalize=off aria-label=Search spellcheck=false onkeydown="if(event.keyCode==13){if(this.value.length){document.getElementById('header-search-submit').click();return false}else{return false}};" autocomplete=off>
<button id=header-search-submit class="mr-1 ml-1 header-search-button" type=submit><svg class="header-search-button-icon" width="13" height="13" viewBox="0 0 13 13"><title>站内搜索</title><path d="m4.8495 7.8226c.82666.0 1.5262-.29146 2.0985-.87438.57232-.58292.86378-1.2877.87438-2.1144.010599-.82666-.28086-1.5262-.87438-2.0985-.59352-.57232-1.293-.86378-2.0985-.87438-.8055-.010599-1.5103.28086-2.1144.87438-.60414.59352-.8956 1.293-.87438 2.0985.021197.8055.31266 1.5103.87438 2.1144.56172.60414 1.2665.8956 2.1144.87438zm4.4695.2115 3.681 3.6819-1.259 1.284-3.6817-3.7.0019784-.69479-.090043-.098846c-.87973.76087-1.92 1.1413-3.1207 1.1413-1.3553.0-2.5025-.46363-3.4417-1.3909s-1.4088-2.0686-1.4088-3.4239.4696-2.4966 1.4088-3.4239c.9392-.92727 2.0864-1.3969 3.4417-1.4088 1.3553-.011889 2.4906.45771 3.406 1.4088.9154.95107 1.379 2.0924 1.3909 3.4239.0 1.2126-.38043 2.2588-1.1413 3.1385l.098834.090049z"/></svg></button></label></form></div></div></div></header></div><div id=start-of-content class=show-on-focus></div><div id=js-flash-container></div></div><div class=application-main data-commit-hovercards-enabled><div itemscope itemtype=http://schema.org/SoftwareSourceCode><main id=js-repo-pjax-container data-pjax-container><div class="pagehead repohead instapaper_ignore readability-menu experiment-repo-nav pt-lg-4"><div class="repohead-details-container clearfix container-lg p-responsive d-lg-block"><div class=d-flex><h1 class="public css-truncate float-none flex-auto width-fit pl-0"><a class="avatar mr-1" href=https://lightjiao.github.io/about/><img src="https://www.gravatar.com/avatar/099703df237acafd6c3b962721f959d7.jpg?s=200" class=avatar-user width=26 height=26></a>
<span class=author><a href=https://lightjiao.github.io/about/>Lightjiao</a></span>
<span class=path-divider>/</span>
<strong itemprop=name><a href=https://lightjiao.github.io/posts/017.coroutine-in-unity/>Unity协程的原理与应用</a></strong><div class="text-small text-gray"><svg class="octicon octicon-tag" viewBox="0 0 14 16" width="14" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.73 1.73C7.26 1.26 6.62 1 5.96 1H3.5C2.13 1 1 2.13 1 3.5v2.47c0 .66.27 1.3.73 1.77l6.06 6.06c.39.39 1.02.39 1.41.0l4.59-4.59a.996.996.0 000-1.41L7.73 1.73zM2.38 7.09c-.31-.3-.47-.7-.47-1.13V3.5c0-.88.72-1.59 1.59-1.59h2.47c.42.0.83.16 1.13.47l6.14 6.13-4.73 4.73-6.13-6.15zM3.01 3h2v2H3V3h.01z"/></svg><a href=/tags/unity/>Unity</a></div><div class="d-block text-small text-gray">Created at <time datetime="2020-11-10 19:03" class=no-wrap>2020/11/10 19:03</time></div></h1></div></div></div><div class="container-lg clearfix new-discussion-timeline experiment-repo-nav p-responsive"><div class=repository-content><div class="Box mt-3 position-relative"><div class="Box-header py-2 d-flex flex-column flex-shrink-0 flex-md-row flex-md-items-center"><div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">7657 Words</div></div><div id=readme class="Box-body readme blob instapaper_body js-code-block-container"><article class="markdown-body entry-content p-3 p-md-6" itemprop=text><blockquote><p>原文地址：https://zhuanlan.zhihu.com/p/279383752</p><p>转载已获得原作者同意</p></blockquote><h2 id=一-unity中使用协程><strong>一. Unity中使用协程</strong><a class=anchor aria-hidden=true href=#一-unity中使用协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h2><h3 id=1-什么是协程><strong>1. 什么是协程</strong><a class=anchor aria-hidden=true href=#1-什么是协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>游戏里面经常会出现类似的淡入淡出效果：“一个游戏物体的颜色渐渐变淡，直至消失。” 当你碰上了类似的需求，也许需要实现一个<code>Fade()</code>来实现这样的淡入淡出效果。</p><p>一个错误的实现是像这个样子的</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>//错误实现
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Fade() 
{
    <span style=color:#66d9ef>float</span> alpha = <span style=color:#ae81ff>1.0f</span>;
    <span style=color:#66d9ef>while</span>(alpha &gt; <span style=color:#ae81ff>0</span>)
    {
        alpha -= Time.deltaTime;
        Color c = renderer.material.color;
        c.a = alpha;
        renderer.material.color = c;
    }
}
</code></pre></div><p>这段代码的思路很简单：在函数中写一个循环，让渲染对象的alpha从1开始不断递减直至降为0。 但是，函数被调用后将运行到完成状态然后返回，函数内的一切逻辑都会在同一帧内完成。也就是说，上述<code>Fade</code>函数中的alpha从1递减到0的过程会在一帧内完成，如果你调用这个<code>Fade</code>函数，看到的将会是游戏物体瞬间消失，而不会渐渐淡出。</p><p>要解决这个错误也很简单，只需将函数改写成协程即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>//正确实现
</span><span style=color:#75715e></span>IEnumerator Fade()
{
    <span style=color:#66d9ef>float</span> alpha = <span style=color:#ae81ff>1.0f</span>;
    <span style=color:#66d9ef>while</span>(alpha &gt; <span style=color:#ae81ff>0</span>)
    {
        alpha -= Time.deltaTime;
        Color c = renderer.material.color;
        c.a = alpha;
        renderer.material.color = c;
        <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;<span style=color:#75715e>//协程会在这里被暂停，直到下一帧被唤醒。
</span><span style=color:#75715e></span>    }
}

<span style=color:#75715e>//Fade不能直接调用，需要使用StartCoroutine(方法名(参数列表))的形式进行调用。
</span><span style=color:#75715e></span>StartCoroutine(Fade());
</code></pre></div><p>像这种以<code>IEnumerator</code>为返回值的函数，在C#里面被称之为迭代器函数，在Unity里面也可以被称为协程函数。 当协程函数运行到<code>yield return null</code>语句时，协程会被暂停，unity继续执行其它逻辑，并在下一帧唤醒协程。</p><p>现在来说说什么是协程，Unity官方对协程的定义是这样的：</p><blockquote><p>A coroutine is like a function that has the ability to pause execution and return control to Unity but then to continue where it left off on the following frame.
By default, a coroutine is resumed on the frame after it yields but it is also possible to introduce a time delay using <a href=https://docs.unity3d.com/ScriptReference/WaitForSeconds.html>WaitForSeconds</a></p></blockquote><p><strong>简单的说，协程就是一种特殊的函数，它可以主动的请求暂停自身并提交一个唤醒条件，Unity会在唤醒条件满足的时候去重新唤醒协程。</strong></p><h3 id=2-如何使用><strong>2. 如何使用</strong><a class=anchor aria-hidden=true href=#2-如何使用><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p><code>MonoBehaviour.StartCoroutine()</code>方法可以开启一个协程，这个协程会挂在该<code>MonoBehaviour</code>下。</p><p>在<code>MonoBehaviour</code>生命周期的<code>Update</code>和<code>LateUpdate</code>之间，会检查这个<code>MonoBehaviour</code>下挂载的所有协程，并唤醒其中满足唤醒条件的协程。</p><p>要想使用协程，只需要以<code>IEnumerator</code>为返回值，并且在函数体里面用<code>yield return</code>语句来暂停协程并提交一个唤醒条件。然后使用<code>StartCoroutine</code>来开启协程。</p><p>下面这个实例展示了协程的用法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp>IEnumerator CoroutineA(<span style=color:#66d9ef>int</span> arg1, <span style=color:#66d9ef>string</span> arg2)
{
    Debug.Log(<span style=color:#e6db74>$&#34;协程A被开启了&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
    Debug.Log(<span style=color:#e6db74>&#34;刚刚协程被暂停了一帧&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(<span style=color:#ae81ff>1.0f</span>);
    Debug.Log(<span style=color:#e6db74>&#34;刚刚协程被暂停了一秒&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> StartCoroutine(CoroutineB(arg1, arg2));
    Debug.Log(<span style=color:#e6db74>&#34;CoroutineB运行结束后协程A才被唤醒&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForEndOfFrame();
    Debug.Log(<span style=color:#e6db74>&#34;在这一帧的最后，协程被唤醒&#34;</span>);
    Debug.Log(<span style=color:#e6db74>&#34;协程A运行结束&#34;</span>);
}

IEnumerator CoroutineB(<span style=color:#66d9ef>int</span> arg1, <span style=color:#66d9ef>string</span> arg2)
{
    Debug.Log(<span style=color:#e6db74>$&#34;协程B被开启了，可以传参数，arg1={arg1}, arg2={arg2}&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(<span style=color:#ae81ff>3.0f</span>);
    Debug.Log(<span style=color:#e6db74>&#34;协程B运行结束&#34;</span>);
}
</code></pre></div><h3 id=3-协程的应用场景><strong>3. 协程的应用场景</strong><a class=anchor aria-hidden=true href=#3-协程的应用场景><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><h3 id=创建补间动画><strong>创建补间动画</strong><a class=anchor aria-hidden=true href=#创建补间动画><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>补间动画指的是在给定若干个关键帧中插值来实现的动画。 如：给定两个时间点的Alpha值，可以插值出一个淡入淡出的动画效果。</p><p>创建补间动画更常用的做法是使用Dotween插件。</p><h3 id=打字机效果><strong>打字机效果</strong><a class=anchor aria-hidden=true href=#打字机效果><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>很多游戏的人物对话界面中，文字并不是一开始就显示在对话框中的，而是一个一个显示出来的。这种将文本一个一个字的显示出来的效果称之为打字机(Typewriter)。</p><p>使用协程，你可以每显示一个字符后等待若干时间，从而实现打字机效果。 b站上有一个基于协程的打字机效果的简单实现（<a href=https://www.bilibili.com/video/BV1cJ411Y7F6>https://www.bilibili.com/video/BV1cJ411Y7F6</a>）</p><h3 id=异步加载资源><strong>异步加载资源</strong><a class=anchor aria-hidden=true href=#异步加载资源><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>资源加载指的是通过IO操作，将磁盘或服务器上的数据加载成内存中的对象。资源加载一般是一个比较耗时的操作，如果直接放在主线程中会导致游戏卡顿，通常会放到异步线程中去执行。</p><p>举个例子，当你需要从服务器上加载一个图片并显示给用户，你需要做两件事情：</p><ol><li>通过IO操作从服务器上加载图片数据到内存中。</li><li>当加载完成后，将图片显示在屏幕上。</li></ol><p>其中，2操作必须等待1操作执行完毕后才能开始执行。</p><p>在传统的互联网应用中，一般会使用回调函数来实现类似功能：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>//伪代码
</span><span style=color:#75715e></span>
<span style=color:#75715e>//提供给用户的接口
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> ShowImageFromUrl(<span style=color:#66d9ef>string</span> url)
{
    LoadImageAsync(url, Callback); <span style=color:#75715e>//开启一个异步线程来加载图像，加载完成后会自动调用回调函数
</span><span style=color:#75715e></span>}

<span style=color:#75715e>//回调函数
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> Callback(Image image)
{
    Show(image);
}   
</code></pre></div><p>我们也可以改写成协程的形式：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>//伪代码
</span><span style=color:#75715e></span>
IEnumerator ShowImageFromUrl(<span style=color:#66d9ef>string</span> url)
{
    Image image = <span style=color:#66d9ef>null</span>;
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> LoadImageAsync(url, image); <span style=color:#75715e>//异步加载图像，加载完成后唤醒协程
</span><span style=color:#75715e></span>    Show(image);
}
</code></pre></div><p>使用协程来进行异步加载在Unity中是一个很常用的写法。资源加载是一个很重的话题，有兴趣的同学可以研究研究。 这里贴两个参考链接： <a href=https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html>Unity官方的异步加载场景的示例</a> <a href=https://zhuanlan.zhihu.com/p/150171940>倩女幽魂手游中的资源加载与更新方案</a></p><h3 id=定时器操作><strong>定时器操作</strong><a class=anchor aria-hidden=true href=#定时器操作><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>当你需要延时执行一个方法或者是每隔一段时间就执行某项操作时，可以使用协程。不过对于这种情况，也可以考虑写一个<code>TickManager</code>来管理定时操作。<a href=https://gitee.com/Taoist_Yu/electricity/blob/master/Assets/Scripts/Engine/CTickMgr.cs>Electricity项目中的定时器</a></p><p><strong>思考：协程能做的Update都能做，那为什么我们需要协程呢？</strong> <strong>答：使用协程，我们可以把一个跨越多帧的操作封装到一个方法内部，代码会更清晰。</strong></p><h3 id=4-注意事项><strong>4. 注意事项</strong><a class=anchor aria-hidden=true href=#4-注意事项><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><ol><li>协程是挂在MonoBehaviour上的，必须要通过一个MonoBehaviour才能开启协程。</li><li>MonoBehaviour被Disable的时候协程会继续执行，只有MonoBehaviour被销毁的时候协程才会被销毁。</li><li>协程看起来有点像是轻量级线程，但是本质上协程还是运行在主线程上的，协程更类似于<code>Update()</code>方法，Unity会每一帧去检测协程需不需要被唤醒。一旦你在协程中执行了一个耗时操作，很可能会堵塞主线程。这里提供两个解决思路：(1) 在耗时算法的循环体中加入<code>yield return null</code>来将算法分到很多帧里面执行；(2) 如果耗时操作里面没有使用Unity API，那么可以考虑在异步线程中执行耗时操作，完成后唤醒主线程中的协程。</li></ol><h2 id=二-unity协程的底层原理><strong>二. Unity协程的底层原理</strong><a class=anchor aria-hidden=true href=#二-unity协程的底层原理><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h2><p>协程分为两部分，协程与协程调度器：协程仅仅是一个能够中间暂停返回的函数，而协程调度是在MonoBehaviour的生命周期中实现的。 准确的说，Unity只实现了协程调度部分，而协程本身其实就是用了C#原生的”迭代器方法“。</p><h3 id=1-协程本体c的迭代器函数><strong>1. 协程本体：C#的迭代器函数</strong><a class=anchor aria-hidden=true href=#1-协程本体c的迭代器函数><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><blockquote><p>许多语言都有迭代器的概念，使用迭代器我们可以很轻松的遍历一个容器。 但是C#里面的迭代器要屌一点，它可以“遍历函数”。</p></blockquote><p>C#中的迭代器方法其实就是一个协程，你可以使用<code>yield</code>来暂停，使用<code>MoveNext()</code>来继续执行。 当一个方法的返回值写成了<code>IEnumerator</code>类型，他就会自动被解析成迭代器方法*（后文直接称之为协程）*，你调用此方法的时候不会真的运行，而是会返回一个迭代器，需要用<code>MoveNext()</code>来真正的运行。看例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
{
    IEnumerator it = Test();<span style=color:#75715e>//仅仅返回一个指向Test的迭代器，不会真的执行。
</span><span style=color:#75715e></span>    Console.ReadKey();
    it.MoveNext();<span style=color:#75715e>//执行Test直到遇到第一个yield
</span><span style=color:#75715e></span>    System.Console.WriteLine(it.Current);<span style=color:#75715e>//输出1
</span><span style=color:#75715e></span>    Console.ReadKey();
    it.MoveNext();<span style=color:#75715e>//执行Test直到遇到第二个yield
</span><span style=color:#75715e></span>    System.Console.WriteLine(it.Current);<span style=color:#75715e>//输出2
</span><span style=color:#75715e></span>    Console.ReadKey();
    it.MoveNext();<span style=color:#75715e>//执行Test直到遇到第三个yield
</span><span style=color:#75715e></span>    System.Console.WriteLine(it.Current);<span style=color:#75715e>//输出test3
</span><span style=color:#75715e></span>    Console.ReadKey();
}

<span style=color:#66d9ef>static</span> IEnumerator Test()
{
    System.Console.WriteLine(<span style=color:#e6db74>&#34;第一次执行&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
    System.Console.WriteLine(<span style=color:#e6db74>&#34;第二次执行&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
    System.Console.WriteLine(<span style=color:#e6db74>&#34;第三次执行&#34;</span>);
    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;test3&#34;</span>;
}
</code></pre></div><ul><li>执行<code>Test()</code>不会运行函数体，会直接返回一个<code>IEnumerator</code></li><li>调用<code>IEnumerator</code>的<code>MoveNext()</code>成员，会执行协程直到遇到第一个<code>yield return</code>或者执行完毕。</li><li>调用<code>IEnumerator</code>的<code>Current</code>成员，可以获得<code>yield return</code>后面接的返回值，该返回值可以是任何类型的对象。</li></ul><p>这里有两个要注意的地方：</p><ol><li><code>IEnumerator</code>中的<code>yield return</code>可以返回任意类型的对象，事实上它还有泛型版本<code>IEnumerator&lt;T></code>，泛型类型的迭代器中只能返回<code>T</code>类型的对象。Unity原生协程使用普通版本的<code>IEnumerator</code>，但是有些项目*（比如倩女幽魂）*自己造的协程轮子可能会使用泛型版本的<code>IEnumerator&lt;T></code></li><li>函数调用的本质是压栈，协程的唤醒也一样，调用<code>IEnumerator.MoveNext()</code>时会把协程方法体压入当前的函数调用栈中执行，运行到<code>yield return</code>后再弹栈。这点和有些语言中的协程不大一样，有些语言的协程会维护一个自己的函数调用栈，在唤醒的时候会把整个函数调用栈给替换，这类协程被称为<strong>有栈协程</strong>，而像C#中这样直接在当前函数调用栈中压入栈帧的协程我们称之为<strong>无栈协程</strong>。关于有栈协程和无栈协程的概念我们会在后文[四. 跳出Unity看协程](#四. 跳出Unity看协程)中继续讨论</li></ol><blockquote><p>Unity中的协程是无栈协程，它不会维护整个函数调用栈，仅仅是保存一个栈帧。</p></blockquote><h3 id=2-协程调度monobehaviour生命周期中实现><strong>2. 协程调度：MonoBehaviour生命周期中实现</strong><a class=anchor aria-hidden=true href=#2-协程调度monobehaviour生命周期中实现><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>仔细翻阅Unity官方文档中介绍<code>MonoBehaviour</code>生命周期的部分，会发现有很多yield阶段，在这些阶段中，Unity会检查<code>MonoBehaviour</code>中是否挂载了可以被唤醒的协程，如果有则唤醒它。</p><p>通过对C#迭代器的了解，我们可以模仿Unity自己实现一个简单的协程调度。这里以<code>YieldWaitForSeconds</code>为例</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>// 伪代码
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> YieldWaitForSeconds()
{
    <span style=color:#75715e>//定义一个移除列表，当一个协程执行完毕或者唤醒条件的类型改变时，应该从当前协程列表中移除。
</span><span style=color:#75715e></span>    List&lt;WaitForSeconds&gt; removeList = <span style=color:#66d9ef>new</span> List&lt;WaitForSeconds&gt;();
    <span style=color:#66d9ef>foreach</span>(IEnumerator w <span style=color:#66d9ef>in</span> m_WaitForSeconds) <span style=color:#75715e>//遍历所有唤醒条件为WaitForSeconds的协程
</span><span style=color:#75715e></span>    {
        <span style=color:#66d9ef>if</span>(Time.time &gt;= w.beginTime() + w.interval) <span style=color:#75715e>//检查是否满足了唤醒条件
</span><span style=color:#75715e></span>        {
            <span style=color:#75715e>//尝试唤醒协程，如果唤醒失败，则证明协程已经执行完毕
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span>(it.MoveNext();)
            {
                <span style=color:#75715e>//应用新的唤醒条件
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span>(!(it.Current <span style=color:#66d9ef>is</span> WaitForSeconds))
                {
                    removeList.Add(it);
                       <span style=color:#75715e>//在这里写一些代码，将it移到其它的协程队列里面去
</span><span style=color:#75715e></span>                }
            }
            <span style=color:#66d9ef>else</span> 
            {
                removeList.Add(it);
            }
        }
    }
    m_WaitForSeconds.RemoveAll(removeList);
}
</code></pre></div><h3 id=3-unity协程的架构><strong>3. Unity协程的架构</strong><a class=anchor aria-hidden=true href=#3-unity协程的架构><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>YieldInstructionWaitForEndOfFrameWaitForFixedUpdateCoroutineWaitForSecondsAsyncOperation
</code></pre></div><p>基类：<a href=https://docs.unity3d.com/ScriptReference/YieldInstruction.html>YieldInstruction</a> 其它所有协程相关的类都继承自这个类。Unity的协程只允许返回继承自<code>YieldInstruction</code>的对象或者<code>null</code>。如果返回了其他对象则会被当成null处理。</p><p>协程类：<a href=https://docs.unity3d.com/ScriptReference/Coroutine.html>Coroutine</a> 你可以通过<code>yield return</code>一个协程来等待一个协程执行完毕，所以<code>Coroutine</code>也会继承自<code>YieldInstruction</code>。 <code>Coroutine</code>仅仅代表一个协程实例，不含任何成员方法，你可以将<code>Coroutine</code>对象传到<code>MonoBehaviour.StopCoroutine</code>方法中去关闭这个协程。</p><p>遗憾的是，Unity关于协程的这套都是在C++层实现的并且几乎没有暴露出C#接口，所以扩展起来会比较麻烦。</p><h2 id=三-扩展unity的协程><strong>三. 扩展Unity的协程</strong><a class=anchor aria-hidden=true href=#三-扩展unity的协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h2><p>了解了协程的底层原理后，就可以尝试去扩展协程啦！！！</p><p><strong>为什么要扩展协程？</strong> 那必然是Unity自带的协程系统无法满足我们的需求了，比如有的时候我们可能需要一个WaitForSceneLoaded或者WaitForAnimationDown之类东西，Unity就没有。</p><p>扩展协程有两个思路，一种是自己另外写一套，可以有高度的定制性；另一种是对Unity现有的协程系统进行封装，可以兼容Unity现有的WaitForXXX。</p><h3 id=1-思路一另外写一套协程><strong>1. 思路一：另外写一套协程</strong><a class=anchor aria-hidden=true href=#1-思路一另外写一套协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>这种其实没什么说的，其实就是自己手写一个协程调度器，有点是可以高度定制调度器行为，缺点是不能兼容Unity自带的协程。</p><p>倩女幽魂的协程轮子是将调度器写到了<code>MonoBehaviour</code>的<code>Update</code>里面，但是你也可以自己在另一个线程开一个死循环来完成协程调度。可以在GitHub上找找别人的代码看看实现，网上那些讲Unity协程的帖子也有很多都实现了简易协程调度。</p><p><a href=https://github.com/OnClick9927/IFramework_CS/tree/master/IFramework/Modules/Coroutine>Github上的某个C#框架下的协程模块，不依赖于Unity</a></p><h3 id=2-思路二在unity协程的基础上进行封装><strong>2. 思路二：在Unity协程的基础上进行封装</strong><a class=anchor aria-hidden=true href=#2-思路二在unity协程的基础上进行封装><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>由于Unity并未暴露出协程的扩展接口，所以不能直接在Unity的协程上进行扩展。 一个折衷的方案是，使用一个代理协程，这个代理协程被Unity管理，然后所有的用户级协程被这个代理协程管理。本质上是对Unity现有协程模块进行封装。</p><p><strong>Electiricy项目中的协程模块：</strong></p><p>在Electricity项目中，有个单例<code>CCoroutineMgr</code>用来管理所有的协程。 使用<code>CCoroutineMgr.Inst.StartCoroutine()</code>即可开启协程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#75715e>//In CCoroutineMgr.cs
</span><span style=color:#75715e></span>
<span style=color:#75715e>//所有扩展的WaitForXXX的接口
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> IWaitable
{
    <span style=color:#66d9ef>bool</span> IsReady();
}

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CCoroutineMgr</span> : CSingletonBehaviour&lt;CCoroutineMgr&gt;
{
    <span style=color:#75715e>//开启一个协程，讲用户传进来的iter传入协程调度器中，协程调度器本身也是一个协程，被Unity管理
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>new</span> WaitForCoroutine StartCoroutine(IEnumerator iter)
    {
        WaitForCoroutine wait = <span style=color:#66d9ef>new</span> WaitForCoroutine();
        <span style=color:#75715e>//开启协程调度器，使用base.StartCoroutine可以开启Unity自带协程
</span><span style=color:#75715e></span>        Coroutine co = <span style=color:#66d9ef>base</span>.StartCoroutine(CoScheduler(iter, wait));
        mCoroutines.Add(wait, co);
        <span style=color:#66d9ef>return</span> wait;
    }
    
    <span style=color:#75715e>//核心：协程调度
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> IEnumerator CoScheduler(IEnumerator iter, WaitForCoroutine wait)
    {
        <span style=color:#66d9ef>while</span> (iter.MoveNext())
        {
            <span style=color:#66d9ef>var</span> res = iter.Current;
            <span style=color:#66d9ef>if</span> (res <span style=color:#66d9ef>is</span> IWaitable) <span style=color:#75715e>//iter中返回了一个IWaitable
</span><span style=color:#75715e></span>            {
                IWaitable waitable = res <span style=color:#66d9ef>as</span> IWaitable;
                <span style=color:#66d9ef>while</span> (!waitable.IsReady())
                    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
            }
            <span style=color:#66d9ef>else</span> <span style=color:#75715e>//iter中返回了一个Unity自带的协程条件
</span><span style=color:#75715e></span>            {
                <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> res;
            }
        }
        mCoroutines.Remove(wait);
    }
}
</code></pre></div><p><a href=https://gitee.com/Taoist_Yu/electricity/blob/master/Assets/Scripts/Engine/CCoroutineMgr.cs>完整代码 CCoroutineMgr.cs</a></p><p><code>IWaitable</code>是所有用户自定义<code>WaitForXXX</code>的公共接口；<code>WaitForCoroutine</code>实现了这个接口，用来表示某个协程有没有结束。</p><p>当开启协程时，用户会传进来一个迭代器方法<code>iter</code>，<code>iter</code>会被传进协程调度器中被调度器管理，而调度器会作为一个Unity原生协程被Unity管理。</p><p>在协程调度器<code>CoScheduler</code>中，当调度器被唤醒，会执行一次<code>iter</code>并检查<code>yield return</code>返回的结果<code>res</code>，如果<code>res</code>是一个<code>IWaitable</code>，就每帧检测<code>res</code>是否满足恢复条件；如果<code>res</code>不是<code>IWaitable</code>，就会将<code>res</code>作为Unity自带的协程唤醒条件返回。</p><p>使用单例的协程管理器可能会导致一些问题，考虑这样一个情况： 对象A请求<code>CCoroutineMgr</code>开启了一个协程C，后来对象A被销毁了而协程C还在运行，协程C会访问已经被销毁了的对象A，从而引发错误。</p><p>在使用单例的协程管理器时，应当注意在对象被销毁的时候将所有引用了这个对象的协程一并销毁。如果每个<code>MonoBehaviour</code>都写一套这样的逻辑可能会比较麻烦，Electricity项目中对<code>MonoBehavioiur</code>做了一些封装，可以自动管理协程的销毁。</p><p><strong>MemoBehaviour</strong></p><p><code>MemoBehaviour</code>可以自动管理协程的销毁，实现比较简单，就直接上代码了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MemoBehaviour</span> : MonoBehaviour
{
    <span style=color:#66d9ef>private</span> List&lt;WaitForCoroutine&gt; mCoroutines = <span style=color:#66d9ef>new</span> List&lt;WaitForCoroutine&gt;();
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> mNextCoroutineClearCount = <span style=color:#ae81ff>10</span>;
    
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>new</span> WaitForCoroutine StartCoroutine(IEnumerator iter)
    {
        WaitForCoroutine wait = CCoroutineMgr.Inst.StartCoroutine(iter);
        mCoroutines.Add(wait);
        <span style=color:#66d9ef>if</span>(mCoroutines.Count &gt;= mNextCoroutineClearCount)
        {
            ClearCoroutines();
            mNextCoroutineClearCount  = mNextCoroutineClearCount * <span style=color:#ae81ff>2</span> + <span style=color:#ae81ff>1</span>;
        }
        <span style=color:#66d9ef>return</span> wait;
    }

    <span style=color:#75715e>//清理已经执行完毕的协程。
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> ClearCoroutines()
    {
        mCoroutines.RemoveAll((WaitForCoroutine wait) =&gt; wait.IsReady());
    }
}
</code></pre></div><p><a href=https://gitee.com/Taoist_Yu/electricity/blob/master/Assets/Scripts/Engine/MemoBehaviour.cs>完整代码 MemoBehaviour.cs</a></p><h2 id=四-跳出unity看协程><strong>四. 跳出Unity看协程</strong><a class=anchor aria-hidden=true href=#四-跳出unity看协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h2><p>前面都是在Unity的基础上讲协程，实际上有很多开发框架中都有协程的概念，而且都有一些区别。这一节就跳出Unity，简单的介绍一下广义上的协程。</p><h3 id=1-进程线程与协程><strong>1. 进程，线程与协程</strong><a class=anchor aria-hidden=true href=#1-进程线程与协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><blockquote><p>进程是操作系统资源分配的基本单位 线程是处理器调度与执行的基本单位</p></blockquote><p>这是操作系统书上对进程与线程的抽象描述。具体一点的说，进程其实就是程序运行的实例：程序本身只是存储在外存上的冷冰冰的二进制流，计算机将这些二进制流读进内存并解析成指令和数据然后执行，程序便成为了进程。</p><p>每一个进程都独立拥有自己的指令和数据，所以称为资源分配的基本单位。其中数据又分布在内存的不同区域，我们在C语言课程中学习过内存四区的概念，一个运行中的进程所占有的内存大体可以分为四个区域：栈区、堆区、数据区、代码区。其中代码区存储指令，另外三个区存储数据。</p><p>线程是处理器调度和执行的基本单位，一个线程往往和一个函数调用栈绑定，一个进程有多个线程，每个线程拥有自己的函数调用栈，同时共用进程的堆区，数据区，代码区。操作系统会不停地在不同线程之间切换来营造出一个并行的效果，这个策略称为时间片轮转法。</p><p>那么协程在其中又处于什么地位呢？ <strong>一切用户自己实现的，类似于线程的轮子，都可以称之为是协程。</strong></p><p>C#中的迭代器方法是协程； Unity在迭代器的基础上扩展出来的协程模块是协程； 你在操作系统实验中模仿线程自己写出来的"线程"也是协程； &mldr;&mldr;..</p><p>协程有什么样的行为，完全由实现协程的程序员来决定（<em>线程和进程都是操作系统中写死的</em>），这就导致了不同开发框架下的协程差别很大。有的协程有自己的函数调用栈，有的协程共用线程的函数调用栈；有的协程是单线程上的，有的协程可以多线程调度；有的协程和线程是一对多的关系，有的协程和线程是多对多的关系。</p><blockquote><p>操作系统可以有多个进程 一个进程对应一个或多个线程 线程和协程的对应关系，由具体的开发框架决定</p></blockquote><h3 id=2-不同框架下协程的共同点><strong>2. 不同框架下协程的共同点</strong><a class=anchor aria-hidden=true href=#2-不同框架下协程的共同点><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>虽然不同开发框架下的协程各不一样，但是这些协程基本上还是有一些共性的</p><h3 id=1-协程有yield和resume操作><strong>(1) 协程有yield和resume操作</strong><a class=anchor aria-hidden=true href=#1-协程有yield和resume操作><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>协程可以通过<code>yield</code>操作挂起，通过<code>resume</code>操作恢复。<code>yield</code>一般是协程主动调用，<code>resume</code>一般是调度器调用。 大多数协程库都支持这两个操作，无非是可能API的名字不一样。 比如C#中，<code>resume</code>操作就是<code>MoveNext</code></p><h3 id=2-协程调度是非抢占式的><strong>(2) 协程调度是非抢占式的</strong><a class=anchor aria-hidden=true href=#2-协程调度是非抢占式的><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><p>线程调度是抢占式的：操作系统会主动中断当前执行中的线程，然后把CPU控制权交给别的线程，就好像有很多线程去争抢CPU的控制权一样。</p><p>协程调度是非抢占式的：协程需要主动调用<code>yield</code>来释放CPU控制权，协程的运行中间不会被系统中断打断。</p><h3 id=3-如何在c语言中造一个协程><strong>3. 如何在C语言中造一个协程</strong><a class=anchor aria-hidden=true href=#3-如何在c语言中造一个协程><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h3><blockquote><p>两个概念：</p></blockquote><ol><li>PC指针：指向CPU下一条运行的指令</li><li>程序运行上下文：这是一个比较宽泛的概念，表示程序运行所需要的数据，比如当前栈帧(无栈协程)或者整个函数调用栈(有栈协程)</li></ol><p>协程的本质就是一个可以暂停执行的函数，使用<code>yiled</code>挂起，使用<code>resume</code>恢复。 只要在协程挂起的时候，保存当前的PC指针和程序运行上下文，然后在协程恢复的时候将保存的数据应用上，即可自己实现一个协程。 有兴趣的话可以去GitHub上找些别人自己写的协程看看源码，直接搜coroutine就好。</p><p><a href=https://github.com/cloudwu/coroutine>云风大神的协程库——基于Unix下的ucontext函数簇</a><br><a href=https://www.bilibili.com/video/BV184411s7qFp%3D26>sylar的协程库——基于ucontext，C++实现</a><br><a href=https://github.com/Taoist-Yu/Coroutine_Win>我的协程库——基于Windows下的纤程API</a></p><h2 id=五-参考资料><strong>五. 参考资料</strong><a class=anchor aria-hidden=true href=#五-参考资料><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a></h2><ol><li><a href=https://docs.unity3d.com/Manual/Coroutines.html>Unity官方的协程文档</a></li><li><a href=https://blog.csdn.net/ybhjx/article/details/55188777>unity3d 协程的初步理解 - 支持返回值/支持异常处理/支持泛型</a></li><li><a href=https://zhuanlan.zhihu.com/p/150171940>倩女幽魂手游中的资源加载与更新方案</a></li><li><a href=https://github.com/OnClick9927/IFramework_CS/tree/master/IFramework/Modules/Coroutine>IFramework-CS的协程模块</a></li><li><a href=https://blog.codingnow.com/2012/07/c_coroutine.html>云风大佬的blog</a></li><li><a href=https://www.bilibili.com/video/BV184411s7qF%3Fp%3D26>sylar的服务端框架中的协程模块</a></li></ol></article></div></div></div></div></main></div></div><div class="utterances mt-4"><script src=https://utteranc.es/client.js repo=lightjiao/lightjiao.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div><div class="footer container-lg width-full p-responsive" role=contentinfo><div class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light"><ul class="list-style-none d-flex flex-wrap col-12 col-lg-5 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0"><li class="mr-3 mr-lg-0">© 2020 Lightjiao. Theme by <a href=https://github.com/MeiK2333/github-style><span>github-style</span></a> (<a href=https://github.com/suihan74/github-style><span>customized</span></a>)</li></ul><a aria-label=Homepage title=Lightjiao的博客 class="footer-octicon d-none d-lg-block mx-lg-4" href=https://lightjiao.github.io><svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><ul class="list-style-none d-flex flex-wrap col-12 col-lg-5 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0"></ul></div><div class="d-flex flex-justify-center pb-6"><span class="f6 text-gray-light"></span></div></div><script crossorigin=anonymous type=application/javascript src=https://lightjiao.github.io/js/frameworks.js></script><script crossorigin=anonymous async type=application/javascript src=https://lightjiao.github.io/js/github-bootstrap.js></script><script>let classs=['pinned-item-desc','text-gray','text-small','d-block','mt-2','mb-3'];const pinned_posts=document.getElementsByName('pinned-post');for(let i=0;i<pinned_posts.length;i++){for(let j=0;j<classs.length;j++){const ps=pinned_posts[i].getElementsByTagName('p');for(let k=0;k<ps.length;k++){ps[k].classList.add(classs[j]);}}}
classs=['d-inline-block','text-gray','mb-2','pr-4'];const posts_posts=document.getElementsByName('posts-post');for(let i=0;i<posts_posts.length;i++){for(let j=0;j<classs.length;j++){const ps=posts_posts[i].getElementsByTagName('p');for(let k=0;k<ps.length;k++){ps[k].classList.add(classs[j]);}}}</script></body></html>